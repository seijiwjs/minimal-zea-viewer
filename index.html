<!DOCTYPE html>
<html>
  <head>
    <title>Zea CAD Viewer</title>
    <link
      rel="shortcut icon"
      type="image/png"
      href="./data/favicon-32x32.png"
    />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.9/tailwind.min.css"
    />

    <style>
      body {
        height: 100vh;
        overflow: hidden;
        margin: 0em;
        background-color: #2d2d2d;
      }
      .layout {
        grid-template-areas:
          "header"
          "main";
        grid-template-rows: 50px 1fr;
      }

      header {
        grid-area: header;
        overflow: hidden;
      }
      main {
        grid-area: main;
        position: relative;
        width: 100%;
        height: 100%;
        background-color: #EEEEEE;
      }

      #logo {
        height: 30px;
      }
      #canvas {
        touch-action: none;
      }

      .progress-display {
        position: absolute;
        left: 0px;
        bottom: 0px;
        width: 100%;
        height: 5px;
      }
      .hidden {
        visibility: hidden;
      }
      .xr-button {
        position: absolute;
        right: 10px;
        bottom: 10px;

        font-family: "arial";
        background-color: #f9ce03; /* Green */
        border: none;
        color: black;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        user-select: none;
      }
      .button:hover {
        background-color: #78b87a; /* Green */
      }
      .button:focus {
        background-color: #78b87a;
      }
    </style>
    <script type="module">
      export class FPSDisplay extends HTMLElement {
        constructor() {
          super();
          const shadowRoot = this.attachShadow({ mode: "open" });

          this.div = document.createElement("div");
          this.div.classList.add("fps-display");
          shadowRoot.appendChild(this.div);

          const styleTag = document.createElement("style");
          styleTag.appendChild(
            document.createTextNode(`
    .fps-display {
        position: fixed;
        bottom: 10px;
        right: 10px;
        color: #333333;
    }
`)
          );
          shadowRoot.appendChild(styleTag);
        }

        set renderer(renderer) {
          let frameCounter = 0;
          renderer.on("redrawOccurred", () => frameCounter++);
          setInterval(() => {
            this.div.textContent = `Fps: ${frameCounter * 2}`;
            frameCounter = 0;
          }, 500);
        }
      }

      customElements.define("fps-display", FPSDisplay);
    </script>
  </head>
  <body class="overflow-hidden">
    <div class="layout grid h-screen">
      <header class="border flex justify-left items-center m-2 border-none">
        <img src="./data/logo-zea.svg" id="logo"></img>
      </header>
      <main>
        <canvas id="canvas"></canvas>
        <div class="xr-button hidden" id="xr-button"></div>
        <fps-display id="fps"></fps-display>
        <progress class="progress-display" id="progress" value="0" max="100">
          0%
        </progress>
      </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-engine@3/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-engine@3/dist/plugins.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-cad@3/dist/index.umd.js"></script>

    <script type="module">
     
    const {
      Color,
      EulerAngles,
      Xfo,
      Quat,
      ObjAsset,
      Scene,
      GLRenderer,
      EnvMap,
      resourceLoader,
      GeomItem,
      MeshProxy,
      LinesProxy,
      Vec3, Sphere, Material,  GLBoundingBoxPass, Cylinder, Cross, Plane, Ray, MathFunctions
    } = zeaEngine;
    const { CADAsset } = zeaCad;

    const urlParams = new URLSearchParams(window.location.search);
    const scene = new Scene();
    // scene.setupGrid(10.0, 100);

    const renderer = new GLRenderer(document.getElementById("canvas"), {
      debugGeomIds: false,
    });
    // renderer.solidAngleLimit = 0.0;
    renderer.setScene(scene);
    renderer
      .getViewport()
      .getCamera()
      .setPositionAndTarget(new Vec3(12, 12, 10), new Vec3(0, 0, 1.5));

    const envMap = new EnvMap();
    envMap.load("./data/StudioG.zenv");
    scene.setEnvMap(envMap);



    

    const default_material = new Material('surfaces', 'SimpleSurfaceShader')
    default_material.getParameter('BaseColor').setValue(new Color(182 / 255, 182 / 255, 182 / 255))
    const rmat = new Material('surfaces', 'SimpleSurfaceShader')
    rmat.getParameter('BaseColor').setValue(new Color(182 / 255, 10 / 255, 10 / 255))
    const bmat = new Material('surfaces', 'SimpleSurfaceShader')
    bmat.getParameter('BaseColor').setValue(new Color(10/ 255, 182 / 255, 10/ 255))
    const gmat = new Material('surfaces', 'SimpleSurfaceShader')
    gmat.getParameter('BaseColor').setValue(new Color(10/ 255, 10 / 255, 182 / 255))

    // transparent for debugging
    const transparent_mat = new Material('surfaces', 'StandardSurfaceShader')
    transparent_mat.getParameter('BaseColor').setValue(1,1,0)
    transparent_mat.getParameter('Metallic').setValue(1.0)
    transparent_mat.getParameter('Reflectance').setValue(1.0)
    transparent_mat.getParameter('Roughness').setValue(0.5)
    transparent_mat.getParameter('Opacity').setValue(5 / 10)

    function createGeo(pos, geom, geomName, mat){
      let m = default_material
      if(mat){
        m = mat
      }
      const geomItem = new GeomItem(geomName, geom,  m)
      const xfo = new Xfo(pos); 
      xfo.ori.setFromEulerAngles(new EulerAngles(90 * (Math.PI / 180), 0, 0));
      geomItem.getParameter("GlobalXfo").setValue(xfo);
      return geomItem
    }
    function f32ArrayToStr(arr){
      let str = ''
      for (let x of arr){
        str+= Math.round(x*100)/100.0 + ' '
      }
      return str
    }
    function printCoord(v1,v2,v3){
      console.log("Coordinate frame:")
      console.log('X: ' + f32ArrayToStr(v1.__data), '\nY: ' + f32ArrayToStr(v2.__data) + '\nZ: ' + f32ArrayToStr(v3.__data))
    }
    function computeCoord(pt1, pt2, pt3){
      const pt12 = pt2.subtract(pt1);
      const pt13 = pt3.subtract(pt1);
      const triNormal = pt13.cross(pt12)
      const normal = pt12.cross(triNormal);
      return [pt12, pt13, normal]
    }

    // alt = set local after
    function setLocalXfos(cy){
      const sphere1 = cy.getChildByName('Sphere1')
      const sphere2 = cy.getChildByName('Sphere2')
      const sphere3 = cy.getChildByName('Sphere3')
      
      sphere1.getParameter("LocalXfo").setValue(s1_xfo)
      sphere2.getParameter("LocalXfo").setValue(s2_xfo)
      sphere3.getParameter("LocalXfo").setValue(s3_xfo)
      const s1_xfo = new Xfo(new Vec3(0,5,0.5))
      const s2_xfo = new Xfo(new Vec3(5,0,0))
      const s3_xfo = new Xfo(new Vec3(0,-5,0.5))
    }

    function add_markers(pt1, pt2, pt3){
      const marker1 = createGeo(pt1, cross, 'Cross1');
      const marker2 = createGeo(pt2, cross, 'Cross2');
      const marker3 = createGeo(pt3, cross, 'Cross3');

      let s1 = createGeo(pt1, marker_geo, 'm1', rmat) 
      let s2 = createGeo(pt2, marker_geo, 'm2', gmat)
      let s3 = createGeo(pt3, marker_geo, 'm3', bmat)

      marker1.addChild(s1)
      marker2.addChild(s2)
      marker3.addChild(s3)


      scene.getRoot().addChild(marker1)
      scene.getRoot().addChild(marker2)
      scene.getRoot().addChild(marker3)

      return [marker1, marker2, marker3]
    }

    function createGeo2(xfo, geom, geomName, mat){
      let m = default_material
      if(mat){
        m = mat
      }
      const geomItem = new GeomItem(geomName, geom,  m)
      geomItem.getParameter("GlobalXfo").setValue(xfo);
      return geomItem
    }
    


    /*
      EXERCISE #1
    */

    const sphere = new Sphere(0.05, 16, 10) // create one sphere and share it -- reuse geo
    const sphere_medium = new Sphere(0.5, 16, 10)
    const sphere_large = new Sphere(1.0, 16, 10)
    const marker_geo = new Sphere(0.001, 8, 5) 
    const cross = new Cross(0.01)
    const origin = new Cross(0.15)
    const cylinder = new Cylinder(0.5, 8, 12)
    const plane_geo = new Plane(0.5, 0.5)
    const plane_large = new Plane(5, 5)
    function computeXfo(pt1, pt2, pt3){
      const pt12 = pt2.subtract(pt1);
      const pt13 = pt3.subtract(pt1);
      const triNormal = pt13.cross(pt12)
      const normal = pt12.cross(triNormal);

      const pos = new Vec3(0,0,0);
      pos.addInPlace(pt1)
      pos.addInPlace(pt2)
      pos.scaleInPlace(0.5)

      const xfo = new Xfo()
      xfo.tr = pos
      const dir = pt2.subtract(pt1);
      xfo.ori.setFromDirectionAndUpvector(dir, normal)

      return xfo
    }
    // return model, like black box
    function createModel(pos1, pos2 ,pos3){
      // Cylinder
      let c = createGeo(new Vec3(0,0,0), cylinder, 'Cylinder') 
      scene.getRoot().addChild(c)

      // Spheres
      let s1 = createGeo(pos1, sphere, 'Sphere1', rmat) 
      let s2 = createGeo(pos2, sphere, 'Sphere2', bmat)
      let s3 = createGeo(pos3, sphere, 'Sphere3', gmat)

      c.addChild(s1, false)
      c.addChild(s2, false)
      c.addChild(s3, false) // false = keep current local offset

      return c
    }

    function orient_cylinder(cy){
      // getting sphere transforms from cylinder parent
      const sphere1 = cy.getChildByName('Sphere1')
      const sphere2 = cy.getChildByName('Sphere2')
      const sphere3 = cy.getChildByName('Sphere3')
      const tr1 = sphere1.getParameter("GlobalXfo").getValue().tr
      const tr2 = sphere2.getParameter("GlobalXfo").getValue().tr
      const tr3 = sphere2.getParameter("GlobalXfo").getValue().tr 
      
      // compute deltas
      const xfo_model = computeXfo(tr1, tr2, tr3)
      const root_xfo = cy.getParameter("GlobalXfo").getValue();
      const model_root_xfo_delta = xfo_model.inverse().multiply(root_xfo)

      const xfo_markers = computeXfo(pt1, pt2, pt3)
      const xfo_delta = xfo_model.inverse().multiply(xfo_markers)

      const xfo = xfo_model.multiply(xfo_delta)
      const final = xfo.multiply(model_root_xfo_delta)

      // let o = createGeo(xfo_model.tr, origin, 'origin')
      // scene.getRoot().addChild(o)
      // apply to model
      cy.getParameter("GlobalXfo").setValue(final);
    }

    function run_exercise(){
      // markers
      const pt1 =  new Vec3(-5,0,4);
      const pt2 =  new Vec3(5,0,-1);
      const pt3 =  new Vec3(0,2,5);

      add_markers(pt1,pt2,pt3)

      // sphere postions - local offsets
      const spos1 = new Vec3(0,-2,-5)
      const spos2 = new Vec3(0,0.5,5)
      const spos3 = new Vec3(0,6,0)

      // create model
      const cy = createModel(spos1, spos2, spos3)
      orient_cylinder(cy)
    }

    
    //run_exercise()

    /*
      PCB EXERCISE
    */


    function load_asset(zcad){
      const asset = new CADAsset();
      
      if (zcad) {
        asset.load(zcad).then(() => {
          let count = 0;
          asset.traverse((item) => {
            if (item instanceof GeomItem) {
              count++;
            }
          });
          console.log("Done GeomItems:", count);
          asset.getGeometryLibrary().on("loaded", () => {
            let triangles = 0;
            let lines = 0;
            asset.traverse((item) => {
              if (item instanceof GeomItem) {
                const geom = item.getParameter("Geometry").getValue();
                if (geom instanceof LinesProxy) {
                  lines += geom.__buffers.indices.length / 2;
                }
                if (geom instanceof MeshProxy) {
                  triangles += geom.__buffers.indices.length / 3;
                }
              }
            });
            console.log("lines: ", lines, " triangles: ", triangles);
          });
          
      
          
          
          renderer.frameAll();
          
        });
      }
      scene.getRoot().addChild(asset);
      return asset
    }

    function computeDelta(root_xfo, model_points, marker_points){
      const [tr1, tr2, tr3] = model_points
      const [pt1, pt2, pt3] = marker_points

      const xfo_model = computeXfo(tr1, tr2, tr3)
   
      const model_root_xfo_delta = xfo_model.inverse().multiply(root_xfo)

      const xfo_markers = computeXfo(pt1, pt2, pt3)
      const xfo_delta = xfo_model.inverse().multiply(xfo_markers)

      const xfo = xfo_model.multiply(xfo_delta)
      const final = xfo.multiply(model_root_xfo_delta)
      return final
    }

    function fit_markers(model_points, marker_points){
      const [s1, s2, s3] = model_points
      const [m1, m2, m3] = marker_points
      const new_s1 = m1.resize(s1.length())
      const new_s2 = m2.resize(s2.length())
      const new_s3 = m3.resize(s3.length())
      return [new_s1,new_s2,new_s3]
    }

    function pcb_exercise(asset){
      // get transforms for holes
      const body1 = [ 'HC_SRO4', 'HC_SRO4', 'Board:1', 'Board', 'Body1', 'Body1'] 
      const body2 = ['HC_SRO4', 'HC_SRO4', 'Board:1', 'Board', 'Body4', 'Body4']
      const body3 = [ 'HC_SRO4', 'HC_SRO4', 'Board:1', 'Board', 'Body3', 'Body3001']
      // const body4 = [ 'HC_SRO4', 'HC_SRO4', 'Board:1', 'Board', 'Body2', 'Body2001']
      const part1 = asset.resolvePath(body1)
      const part2 = asset.resolvePath(body2)
      const part3 = asset.resolvePath(body3)
      //const part4 = asset.resolvePath(body4)
      const p1 = part1.getGeomMat4().translation
      const p2 = part2.getGeomMat4().translation
      const p3 = part3.getGeomMat4().translation
      //const p4 = part4.getGeomMat4().translation
   
      // visualize holes
      const m1 = createGeo(p1, marker_geo, 'mark1', rmat)
      part1.addChild(m1)
      const m2 = createGeo(p2, marker_geo, 'mark2', gmat)
      part2.addChild(m2)
      const m3 = createGeo(p3, marker_geo, 'mark3', bmat)
      part3.addChild(m3)
      // const m4 = createGeo(p4, marker_geo, 'mark4', bmat)
      // scene.getRoot().addChild(m4)


      /*
        Set Markers
      */
      const marker_pt1 =  new Vec3(-0.05,0,0.04);
      const marker_pt2 =  new Vec3(0.05,0,-0.01);
      const marker_pt3 =  new Vec3(0,0.02,0.05);
      
      const [pt1,pt2,pt3] = fit_markers([p1,p2,p3],[marker_pt1,marker_pt2,marker_pt3])
      add_markers(pt1,pt2,pt3)

      // compute coordinate frame for markers and visualize frame
      const xfo = computeXfo(pt1,pt2,pt3)
      const origin_geo = createGeo2(xfo, origin, 'origin')
      scene.getRoot().addChild(origin_geo)
      

      /*
        Compute Delta
      */
      //get root transform
      const model_root_xfo = asset.getParameter("GlobalXfo").getValue();
 
      // compute deltas. 
      const delta_xfo = computeDelta(model_root_xfo, [p1,p2,p3],[pt1,pt2,pt3])

      // visualize new xfo
      const model_origin_geo = createGeo2(delta_xfo, origin, 'origin')
      scene.getRoot().addChild(model_origin_geo)

      //apply to model
      asset.getParameter("GlobalXfo").setValue(delta_xfo );
    }

    // const asset = load_asset("./data/HC_SRO4.zcad")
    // asset.on("loaded", () => {
    //   pcb_exercise(asset)
    // })

    
    /*
      Mouse Exercise
    */


    function get_hit_point(event){
        const dist  = event.intersectionData.dist
        const dir = event.pointerRay.dir
        const start = event.pointerRay.start
        const hit_pt = start.add(dir.scale(dist))

        return hit_pt
    }

    function create_point(event){
        const hit_pt = get_hit_point(event)
        const obj_hit = createGeo2(new Xfo(hit_pt), sphere, 'hit_marker', bmat)
        scene.getRoot().addChild(obj_hit)
    }

    function get_hit_plane_pointer(event){
        const dist  = event.intersectionData.dist
        const dir = event.pointerRay.dir
        const start = event.pointerRay.start
        const hit_pt = start.add(dir.scale(dist))

        return new Ray(hit_pt, dir)
    }

    function create_plane_pointer(event){
      const ray = get_hit_plane_pointer(event)
      const quat = new Quat()
      quat.setFromDirectionAndUpvector(ray.dir, new Vec3(0,0,1))
      const xfo = new Xfo(ray.start, quat)

      const obj_hit = createGeo2(xfo, plane_geo, 'hit_marker', gmat)
      scene.getRoot().addChild(obj_hit)
    }



   function get_hit_pos_floor(event){
        const dir = event.pointerRay.dir
        const start = event.pointerRay.start
        const ray = new Ray(start, dir)
        const floor = new Ray(new Vec3(0,0,0), new Vec3(0,0,1))
        const dist = ray.intersectRayPlane(floor)
        const hit_pt = start.add(dir.scale(dist))
        return hit_pt
    }

    function create_plane_floor(event){
      const hit_pt = get_hit_pos_floor(event)

      const obj_hit = createGeo2(new Xfo(hit_pt), plane_geo, 'hit_marker', gmat)
      scene.getRoot().addChild(obj_hit)
    }
    
    function create_plane_floor_discrete(event){
      const hit_pt = get_hit_pos_floor(event)
      const pt = new Vec3(
       Math.round(hit_pt.x)+0.5,
       Math.round(hit_pt.y)+0.5, 
       Math.round(hit_pt.z))
      const obj_hit = createGeo2(new Xfo(pt), plane_geo, 'hit_marker', gmat)
      scene.getRoot().addChild(obj_hit)
    }


    //TODO: use grid plane as dragging surface
    //TODO: lerp
    function createDraggable(xfo, geom, geomName, mat){
      let m = default_material
      if(mat){
        m = mat
      }
      const geomItem = new GeomItem(geomName, geom,  m)
      addListeners_draggable(geomItem, grid_size)
      return geomItem
    }

    // EXTRA: grid snapping
    function addListeners_draggable(geomItem, gridSize){
      let dragging = false
      let initial_xfo = null
      let last_xfo = null

      geomItem.on('pointerDown', event => {
        initial_xfo = geomItem.getParameter("GlobalXfo").getValue()
        event.setCapture(geomItem)
        dragging = true
      })
 
      geomItem.on('pointerMove', event => {
        if(dragging){
          const hit_pt = get_hit_pos_floor(event)
          const hit_xfo = geomItem.getParameter("GlobalXfo").getValue();
          const old_pos = hit_xfo.tr
          
          const x = Math.min(Math.max(hit_pt.x, -gridSize/2.0), gridSize/2.0)
          const y = Math.min(Math.max(hit_pt.y, -gridSize/2.0), gridSize/2.0)
          const new_pos = new Vec3(x,y,old_pos.z)

          // const pos = MathFunctions.lerp(old_pos, new_pos, 0.5)
          hit_xfo.tr = new_pos;
          geomItem.getParameter("GlobalXfo").setValue(hit_xfo);
          last_xfo = hit_xfo
        }
      })

      geomItem.on('pointerUp', event => {
        if(event.getCapture() == geomItem) {
          dragging = false
          event.releaseCapture()
          console.log("new pos: ", [last_xfo.tr.x, last_xfo.tr.y,last_xfo.tr.z] )
        }
      })
    }

    // function getTime(){
    //   const date = new Date();
    //   const t = date.getTime();
    //   return t-t0
    // }

    function createDraggable2(xfo, geom, geomName, mat){
      let m = default_material
      if(mat){
        m = mat
      }
      const geomItem = new GeomItem(geomName, geom,  m)
      addListeners_draggable2(geomItem, grid_size)
      return geomItem
    }

    function get_hit_plane(event){
        const dist  = event.intersectionData.dist
        const dir = event.pointerRay.dir
        const start = event.pointerRay.start
        const hit_pt = start.add(dir.scale(dist))

        return new Ray(hit_pt, dir)
    }
    function create_plane(event){
      const quat = new Quat()
      const cam = event.viewport.getCamera()
      const cam_xfo = cam.getParameter("GlobalXfo").getValue()
      const cam_ori = cam_xfo.ori
      const cam_forward = cam_ori.getZaxis()

      quat.setFromDirectionAndUpvector(cam_forward, new Vec3(0,0,1))
      const xfo = new Xfo(event.pointerRay.start, quat)

      const obj_hit = createGeo2(xfo, plane_geo, 'hit_marker', gmat)
      scene.getRoot().addChild(obj_hit)
    }

    // TODO: wip. Plane that removes itself on pointerUp
    function visualize_plane(hit_plane){
      
      const vquat = new Quat()
      vquat.setFromDirectionAndUpvector(hit_plane.dir, new Vec3(0,0,1))
      const vxfo = new Xfo(hit_plane.start, vquat)
      const vplane = createGeo2(vxfo, plane_large, 'plane', gmat)

      // scene.getRoot().addChild(vplane)
      // vplane.on('pointerUp', event => {
      //   scene.getRoot().removeChild(vplane)
      // })
    }
   
    function addListeners_draggable2(geomItem, gridSize){
      let dragging = false
      let initial_xfo = null
      let last_xfo = null
      let hit_plane = null
      let viz_plane = null

      geomItem.on('pointerDown', event => {
        initial_xfo = geomItem.getParameter("GlobalXfo").getValue()
        hit_plane = get_hit_plane(event)
        viz_plane = visualize_plane(hit_plane)
        
        event.setCapture(geomItem)
        dragging = true
      })
      
      geomItem.on('pointerMove', event => {
        if(dragging){
          const ray = event.pointerRay
          const dist = ray.intersectRayPlane(hit_plane)
          const hit_pt = ray.pointAtDist(dist)
          const geom_xfo = geomItem.getParameter("GlobalXfo").getValue();
          const old_pos = geom_xfo.tr
          const new_pos = hit_pt
          geom_xfo.tr = new_pos;
          geomItem.getParameter("GlobalXfo").setValue(geom_xfo);
          last_xfo = geom_xfo
        }
      })

      geomItem.on('pointerUp', event => {
        if(event.getCapture() == geomItem) {
          dragging = false
          event.releaseCapture()
          hit_plane = null
        }

      })
    }

    const grid_size = 10
    scene.setupGrid(grid_size, 100);

    /*
      MAIN
    */
   
    const mode = 1;
    
    // grid drag
    if(mode == 0){
      const xfo = new Xfo(new Vec3(0,0.5,0))
      const draggable_sphere = createDraggable(xfo, sphere_large, 'marker1000', rmat) // register event
      scene.getRoot().addChild(draggable_sphere)
      // TODO: time + frame for lerp -- best way?
    } else if(mode == 1){
      const xfo = new Xfo(new Vec3(0,0.5,0))
      const draggable_sphere = createDraggable2(xfo, sphere_large, 'marker1000', rmat) // register event
      scene.getRoot().addChild(draggable_sphere)
    }


    // TODO: adapt to previous exercises


    /*
      UI
    */
    let highlightedItem;
      renderer.getViewport().on("pointerOverGeom", (event) => {
        highlightedItem = event.intersectionData.geomItem;
        highlightedItem.addHighlight(
          "pointerOverGeom",
          new Color(0.8, 0.8, 0.8, 0.1),
          true
        );
      });
      renderer.getViewport().on("pointerLeaveGeom", (event) => {
        highlightedItem.removeHighlight("pointerOverGeom", true);
        highlightedItem = null;
      });

      // let selected_obj = null
      // let selected_transform = null
      // renderer.getViewport().on("pointerDown", (event) => {
      //   if (event.intersectionData) {
      //     const { geomItem } = event.intersectionData;
      //     selected_obj = geomItem

      //     selected_transform = selected_obj.__globalXfoParam.getValue().tr
      //     console.log("selected: ", selected_obj.__name)
      //     console.log("selected transform: ", selected_transform)
      //     // console.log(geomItem.getPath());

      //     selected_transform.addInPlace(new Vec3(0,1,0)) // works
          
      //   }
      // });
      // renderer.getViewport().on("pointerMove", (event) => {
      //     // need frustrums viewing plane... 
      // });
      // renderer.getViewport().on("pointerUp", (event) => {
      //   selected_obj = null
      //   let selected_transform = null
      // });
    /*
      Exercise end
    */
      // Setup FPS Display
      const fpsElement = document.getElementById("fps");
      fpsElement.renderer = renderer;

      resourceLoader.on("progressIncremented", (event) => {
        const pct = document.getElementById("progress");
        pct.value = event.percent;
        if (event.percent >= 100) {
          setTimeout(() => pct.classList.add("hidden"), 1000);
        }
      });

      renderer.getXRViewport().then((xrvp) => {
        fpsElement.style.bottom = "70px";

        const xrButton = document.getElementById("xr-button");
        xrButton.textContent = "Launch VR";
        xrButton.classList.remove("hidden");

        xrvp.on("presentingChanged", (event) => {
          const { state } = event;
          if (state) {
            xrButton.textContent = "Exit VR";
          } else {
            xrButton.textContent = "Launch VR";
          }
        });

        xrButton.addEventListener("click", function (event) {
          xrvp.togglePresenting();
        });

        document.addEventListener("keydown", (event) => {
          if (event.key == " ") {
            xrvp.togglePresenting();
          }
        });
      });

      if (urlParams.has("profile")) {
        renderer.startContinuousDrawing();
      }
    </script>
  </body>
</html>
