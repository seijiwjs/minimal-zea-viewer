<!DOCTYPE html>
<html>
  <head>
    <title>Zea CAD Viewer</title>
    <link
      rel="shortcut icon"
      type="image/png"
      href="./data/favicon-32x32.png"
    />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.9/tailwind.min.css"
    />

    <style>
      body {
        height: 100vh;
        overflow: hidden;
        margin: 0em;
        background-color: #2d2d2d;
      }
      .layout {
        grid-template-areas:
          "header"
          "main";
        grid-template-rows: 50px 1fr;
      }

      header {
        grid-area: header;
        overflow: hidden;
      }
      main {
        grid-area: main;
        position: relative;
        width: 100%;
        height: 100%;
        background-color: #EEEEEE;
      }

      #logo {
        height: 30px;
      }
      #canvas {
        touch-action: none;
      }

      .progress-display {
        position: absolute;
        left: 0px;
        bottom: 0px;
        width: 100%;
        height: 5px;
      }
      .hidden {
        visibility: hidden;
      }
      .xr-button {
        position: absolute;
        right: 10px;
        bottom: 10px;

        font-family: "arial";
        background-color: #f9ce03; /* Green */
        border: none;
        color: black;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        user-select: none;
      }
      .button:hover {
        background-color: #78b87a; /* Green */
      }
      .button:focus {
        background-color: #78b87a;
      }
    </style>
    <script type="module">
      export class FPSDisplay extends HTMLElement {
        constructor() {
          super();
          const shadowRoot = this.attachShadow({ mode: "open" });

          this.div = document.createElement("div");
          this.div.classList.add("fps-display");
          shadowRoot.appendChild(this.div);

          const styleTag = document.createElement("style");
          styleTag.appendChild(
            document.createTextNode(`
    .fps-display {
        position: fixed;
        bottom: 10px;
        right: 10px;
        color: #333333;
    }
`)
          );
          shadowRoot.appendChild(styleTag);
        }

        set renderer(renderer) {
          let frameCounter = 0;
          renderer.on("redrawOccurred", () => frameCounter++);
          setInterval(() => {
            this.div.textContent = `Fps: ${frameCounter * 2}`;
            frameCounter = 0;
          }, 500);
        }
      }

      customElements.define("fps-display", FPSDisplay);
    </script>
  </head>
  <body class="overflow-hidden">
    <div class="layout grid h-screen">
      <header class="border flex justify-left items-center m-2 border-none">
        <img src="./data/logo-zea.svg" id="logo"></img>
      </header>
      <main>
        <canvas id="canvas"></canvas>
        <div class="xr-button hidden" id="xr-button"></div>
        <fps-display id="fps"></fps-display>
        <progress class="progress-display" id="progress" value="0" max="100">
          0%
        </progress>
      </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-engine@3/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-engine@3/dist/plugins.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zeainc/zea-cad@3/dist/index.umd.js"></script>

    <script type="module">
     
      const {
        Color,
        EulerAngles,
        Xfo,
        Quat,
        ObjAsset,
        Scene,
        GLRenderer,
        EnvMap,
        resourceLoader,
        GeomItem,
        MeshProxy,
        LinesProxy,
        Vec3, Sphere, Material,  GLBoundingBoxPass, Cylinder, Cross
      } = zeaEngine;
      const { CADAsset } = zeaCad;

      const urlParams = new URLSearchParams(window.location.search);
      const scene = new Scene();
      scene.setupGrid(10.0, 10);

      const renderer = new GLRenderer(document.getElementById("canvas"), {
        debugGeomIds: false,
      });
      // renderer.solidAngleLimit = 0.0;
      renderer.setScene(scene);
      renderer
        .getViewport()
        .getCamera()
        .setPositionAndTarget(new Vec3(12, 12, 10), new Vec3(0, 0, 1.5));

      const envMap = new EnvMap();
      envMap.load("./data/StudioG.zenv");
      scene.setEnvMap(envMap);

      // scene.getRoot().addChild(asset);
      const standardMaterial = new Material('surfaces', 'SimpleSurfaceShader')
      standardMaterial.getParameter('BaseColor').setValue(new Color(182 / 255, 182 / 255, 182 / 255))
      // create another mat for pts

      const sphere = new Sphere(0.5, 16, 10) // create one sphere and share it -- reuse geo
      const cross = new Cross(0.5) // create one sphere and share it -- reuse geo
      const cylinder = new Cylinder(1, 8, 12)

      function createGeo(pos, geom, geomName, add){
        const geomItem = new GeomItem(geomName, geom, standardMaterial)
        const xfo = new Xfo(pos);
        xfo.ori.setFromEulerAngles(new EulerAngles(90 * (Math.PI / 180), 0, 0));
        geomItem.getParameter("GlobalXfo").setValue(xfo);
        if(add) scene.getRoot().addChild(geomItem)
        return geomItem
      }

      function f32ArrayToStr(arr){
        let str = ''
        for (let x of arr){
          str+= Math.round(x*100)/100.0 + ' '
        }
        return str
      }
      function printCoord(v1,v2,v3){
        console.log("Coordinate frame:")
        console.log('X: ' + f32ArrayToStr(v1.__data), '\nY: ' + f32ArrayToStr(v2.__data) + '\nZ: ' + f32ArrayToStr(v3.__data))
      }

      function computeCoord(pt1, pt2, pt3){
        const pt12 = pt2.subtract(pt1);
        const pt13 = pt3.subtract(pt1);
        const triNormal = pt13.cross(pt12)
        const normal = pt12.cross(triNormal);
        return [pt12, pt13, normal]
      }


      // create geometry
      let c = createGeo(new Vec3(0,0,0), cylinder, 'Cylinder', true)

      let s1 = createGeo(new Vec3(0,0.5,5), sphere, 'Sphere', false) // get globalXfo.tr
      let s2 = createGeo(new Vec3(0,0.5,-5), sphere, 'Sphere', false)
      let s3 = createGeo(new Vec3(0,0.5,-5), sphere, 'Sphere', false)

      c.addChild(s1, false)
      c.addChild(s2, false)
      c.addChild(s3, false)

      const tr1 = s1.getParameter("GlobalXfo").getValue().tr
      const tr2 = s2.getParameter("GlobalXfo").getValue().tr
      const tr3 = s2.getParameter("GlobalXfo").getValue().tr

      // calc coord frame from spheres.
      const dirSpheres = tr2.subtract(tr1);
      const [trX, trY, trZ] = computeCoord(tr1, tr2, tr3)
      printCoord(trX, trY, trZ);


      // markers
      const pt1 =  new Vec3(-7,0,4);
      const pt2 =  new Vec3(-3,0,-1);
      const pt3 =  new Vec3(0,0,5);

      const marker1 = createGeo(pt1,cross, 'Cross', true);
      const marker2 = createGeo(pt2,cross, 'Cross', true);
      const marker3 = createGeo(pt3,cross, 'Cross', true);


      //calc coords from markers
      const [x,y,z] = computeCoord(pt1, pt2,pt3)
      printCoord(x, y, z);

      // set cylinder
      const dir = pt2.subtract(pt1);
      const quat = new Quat();
      quat.setFromDirectionAndUpvector(dir, z);

      // position for cylinder
      const pos = new Vec3(0,0,0);
      pos.addInPlace(pt1)
      pos.addInPlace(pt2)
      pos.scaleInPlace(0.5)

      const scale = new Vec3(1,1,1)
      const xfo = new Xfo(pos, quat, scale );
      c.getParameter("GlobalXfo").setValue(xfo);

      // calc differnce -> inverseOfXfo

      // invertCrossXfo * sphereXfo




      /*
        Exercise end
      */

      // Setup FPS Display
      const fpsElement = document.getElementById("fps");
      fpsElement.renderer = renderer;

      let highlightedItem;
      renderer.getViewport().on("pointerOverGeom", (event) => {
        highlightedItem = event.intersectionData.geomItem;
        highlightedItem.addHighlight(
          "pointerOverGeom",
          new Color(0.8, 0.8, 0.8, 0.1),
          true
        );
      });
      renderer.getViewport().on("pointerLeaveGeom", (event) => {
        highlightedItem.removeHighlight("pointerOverGeom", true);
        highlightedItem = null;
      });
      renderer.getViewport().on("pointerDown", (event) => {
        if (event.intersectionData) {
          const { geomItem } = event.intersectionData;
          console.log(geomItem.getPath());
        }
      });

      resourceLoader.on("progressIncremented", (event) => {
        const pct = document.getElementById("progress");
        pct.value = event.percent;
        if (event.percent >= 100) {
          setTimeout(() => pct.classList.add("hidden"), 1000);
        }
      });

      renderer.getXRViewport().then((xrvp) => {
        fpsElement.style.bottom = "70px";

        const xrButton = document.getElementById("xr-button");
        xrButton.textContent = "Launch VR";
        xrButton.classList.remove("hidden");

        xrvp.on("presentingChanged", (event) => {
          const { state } = event;
          if (state) {
            xrButton.textContent = "Exit VR";
          } else {
            xrButton.textContent = "Launch VR";
          }
        });

        xrButton.addEventListener("click", function (event) {
          xrvp.togglePresenting();
        });

        document.addEventListener("keydown", (event) => {
          if (event.key == " ") {
            xrvp.togglePresenting();
          }
        });
      });

      if (urlParams.has("profile")) {
        renderer.startContinuousDrawing();
      }
    </script>
  </body>
</html>
